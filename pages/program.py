"""program.py

Utility to take the table rows from program-start.html and edit it, mostly to
make them look nicer and to add links to the pdfs.

This assumes that in program-start.html each <tr> is at the beginning of a line
(this may need a little manual edit of the input file).

Note that program-start.html was originally generated by the start site, but
that it was edited so it looks like all the other pages in the LAW-XI website
(adding header and foot and navigation and such).

Prints rows to stdout. The output of this script should replace program.html.

"""

from HTMLParser import HTMLParser
import sys, StringIO


TABLE = StringIO.StringIO()

# list of titles with mapping to count identifier in pdf files
TITLES = {
    'Readers vs. Writers vs. Texts: Coping with Different Perspectives of Text Understanding in Emotion Annotation': '01',
    'Finding Good Conversations Online: The Yahoo News Annotated Comments Corpus': '02',
    'Crowdsourcing discourse interpretations: On the influence of context and the reliability of a connective insertion task': '03',
    'A Code-Switching Corpus of Turkish-German Conversations': '04',
    'Annotating omission in statement pairs': '05',
    'Annotating Speech, Attitude and Perception Reports': '06',
    'Consistent Classification of Translation Revisions: A Case Study of English-Japanese Student Translations': '07',
    'Representation and Interchange of Linguistic Annotation. An In-Depth, Side-by-Side Comparison of Three Designs': '08',
    'TDB 1.1: Extensions on Turkish Discourse Bank': '09',
    'Two Layers of Annotation for Representing Event Mentions in News Stories': '10',
    'Word Similarity Datasets for Indian Languages: Annotation and Baseline Systems': '11',
    'The BECauSE Corpus 2.0: Annotating Causality and Overlapping Relations': '12',
    'Catching the Common Cause: Extraction and Annotation of Causal Relations and their Participants': '13',
    'Assessing SRL Frameworks with Automatic Training Data Expansion': '14'
}


class Parser(HTMLParser):

    def handle_starttag(self, tag, attrs):
        #print "Encountered a start tag:", tag, attrs
        if tag == 'tr':
            TABLE.write("\n")
        elif tag == 'td':
            TABLE.write("\n  ")
        if tag == 'a':
            return
        if attrs:
            attrs = adjust_attributes(attrs)
            #sys.stderr.write("%s\n" % attrs)
            TABLE.write("<%s %s>" % (tag, ' '.join(["%s=\"%s\"" % (a,v) for a,v in attrs])))
        else:
            TABLE.write("<%s>" % tag)

    def handle_endtag(self, tag):
        #print "Encountered an end tag :", tag
        TABLE.write("</%s>" % tag)

    def handle_data(self, data):
        #print "Encountered some data  :", data
        if data.startswith('Invited'):
            sys.stderr.write(data + "\n")
        if data.startswith('Invited Talk I'):
            data += ". <a class=paper href=invited.html>(abstract)</a>"
        elif data in TITLES:
            data += ". (<a class=paper href=papers/LAW%s.pdf>pdf</a>)" % TITLES[data]
        #if not data[0] in ('0', '1', '2', '3', '4', '5', '6', '7', '8', '9') and len(data) > 10:
        #    sys.stderr.write('>>>'+data+"\n")
            
        TABLE.write(data)
        
    def handle_charref(self, data):
        #print "Encountered charref    :", data
        TABLE.write("&#%s;" % data)
        
    def handle_entityref(self, data):
        #print "Encountered entref     :", data
        TABLE.write("&%s;" % data)


def adjust_attributes(attrs):
    new_attrs = []
    if find_attribute(attrs, 'colspan'):
        #sys.stderr.write("%s\n" % attrs)
        for a,v in attrs:
            if a == 'style':
                continue
            new_attrs.append((a,v))
        #sys.stderr.write("%s\n" % new_attrs)
    else:
        for a,v in attrs:
            if a == 'width':
                new_attrs.append((a, '125'))
                #sys.stderr.write("%s\n" % new_attrs)
            else:
                new_attrs.append((a,v))
    return new_attrs


def find_attribute(attrs, attr):
    #sys.stderr.write("%s\n" % attrs)
    for a,v in attrs:
        #sys.stderr.write("  %s == %s\n" % (a,attr))
        if a == attr:
            #sys.stderr.write("  %s == %s\n" % (a,attr))
            return True
    return False


def do_table(table):
    parser = Parser()
    parser.feed(table.getvalue())
    print TABLE.getvalue()


parts = {
    'start': StringIO.StringIO(),
    'table': StringIO.StringIO(),
    'end': StringIO.StringIO() }

location = 'start'
        
for line in open('program-start.html'):
    if line.startswith('<table'):
        location = 'table'
    elif line.startswith('</table'):
        location = 'end'
    parts[location].write(line)
    
print parts['start'].getvalue()
do_table(parts['table'])
print parts['end'].getvalue()
